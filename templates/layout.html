<!doctype html>
<html lang="en" data-bs-theme="light">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>{% block title %}TuneForge{% endblock %}</title>
    <link rel="icon" href="{{ url_for('static', filename='images/logo_small.jpeg') }}" type="image/jpeg">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <!-- If you plan to use Bootstrap JS components, uncomment the line below -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script> -->
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <img src="{{ url_for('static', filename='images/logo_big.jpeg') }}" alt="Logo" class="sidebar-logo" style="width:240px; height:auto; margin-bottom:10px;"> 
            <!-- Hidden h2 for accessibility if logo is the main title, or replace with actual text -->
            <h2>TuneForge</h2> 
            <p class="tagline">TuneForge<br>AI Powered Playlists</p>
        </div>
        <nav class="sidebar-nav">
            <div class="sidebar-section">
                <h3>Menu</h3>
                <ul>
                    <li><a href="{{ url_for('main.index') }}" class="{% if request.endpoint == 'main.index' %}active{% endif %}">Generate</a></li>
                    <li><a href="{{ url_for('main.local_music_page') }}" class="{% if request.endpoint == 'main.local_music_page' %}active{% endif %}">Local Music</a></li>
                    <li><a href="{{ url_for('main.history') }}" class="{% if request.endpoint == 'main.history' %}active{% endif %}">History</a></li>
                    <li><a href="{{ url_for('main.settings') }}" class="{% if request.endpoint == 'main.settings' %}active{% endif %}">Settings</a></li>
                </ul>
            </div>
        </nav>
        
                    <!-- Simple Floating Progress Indicator -->
            <div id="floating-progress" class="floating-progress" style="display: none;">
                <div id="progress-content"></div>
            </div>
        
        <div class="sidebar-footer">
            <p class="version-info">v0.1.2</p>
        </div>
    </div>

    <div class="main-content">
        {% block content %}{% endblock %}
    </div>

    <script>
        // Basic dark mode toggle based on your original script, adapted for new structure
        document.addEventListener('DOMContentLoaded', function() {
            const themeToggleBtn = document.getElementById('theme-toggle-btn'); // Assuming you'll add this button somewhere
            const htmlElement = document.documentElement;
            
            function updateThemeIcon(theme) {
                // Logic to update an icon if you have one, e.g., in the sidebar or main content header
                // For now, this is a placeholder.
                // Example: if (theme === 'dark') { darkIcon.style.display = 'none'; lightIcon.style.display = 'block'; }
            }

            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                htmlElement.setAttribute('data-bs-theme', savedTheme);
                updateThemeIcon(savedTheme);
            } else {
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                const initialTheme = prefersDark ? 'dark' : 'light';
                htmlElement.setAttribute('data-bs-theme', initialTheme);
                updateThemeIcon(initialTheme);
            }
            
            if (themeToggleBtn) {
                themeToggleBtn.addEventListener('click', function() {
                    const currentTheme = htmlElement.getAttribute('data-bs-theme');
                    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                    htmlElement.setAttribute('data-bs-theme', newTheme);
                    localStorage.setItem('theme', newTheme);
                    updateThemeIcon(newTheme);
                });
            }
        });
    </script>
    
    <!-- Global Status Management Script -->
    <script>
    // Global status management with robust persistence
    window.globalStatusManager = {
        activeScans: new Map(),
        progressPanel: null,
        progressContent: null,
        pollIntervals: new Map(),
        
        init() {
            this.progressPanel = document.getElementById('floating-progress');
            this.progressContent = document.getElementById('progress-content');
            
            // Restore state from localStorage
            this.restoreState();
            
            // Start background polling
            this.startBackgroundPolling();
            
            // Ensure progress panel is visible if there are active tasks
            this.ensureVisibility();
            
            // Set up page visibility and focus handlers
            this.setupEventHandlers();
        },
        
        // Persistent state management
        saveState() {
            const state = {
                activeScans: Array.from(this.activeScans.entries()),
                timestamp: Date.now()
            };
            localStorage.setItem('globalStatusManagerState', JSON.stringify(state));
        },
        
        restoreState() {
            try {
                const savedState = localStorage.getItem('globalStatusManagerState');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    const now = Date.now();
                    
                    // Only restore if state is less than 1 hour old
                    if (now - state.timestamp < 3600000) {
                        this.activeScans = new Map(state.activeScans);
                        console.log(`Restored ${this.activeScans.size} active scans from localStorage`);
                    } else {
                        console.log('Saved state too old, starting fresh');
                        localStorage.removeItem('globalStatusManagerState');
                    }
                }
            } catch (error) {
                console.error('Error restoring state:', error);
                localStorage.removeItem('globalStatusManagerState');
            }
        },
        
        showPanel() {
            if (this.progressPanel) {
                this.progressPanel.style.display = 'block';
                this.saveState();
            }
        },
        
        hidePanel() {
            if (this.progressPanel) {
                this.progressPanel.style.display = 'none';
                this.saveState();
            }
        },
        
        addScan(scanId, folderPath) {
            this.activeScans.set(scanId, {
                id: scanId,
                folder: folderPath,
                status: 'starting',
                progress: 0,
                currentFile: '',
                totalFiles: 0,
                processedFiles: 0,
                startTime: Date.now()
            });
            
            this.showPanel();
            this.updateDisplay();
            this.startPolling(scanId);
            this.saveState();
        },
        
        updateScan(scanId, data) {
            const scan = this.activeScans.get(scanId);
            if (scan) {
                Object.assign(scan, data);
                this.updateDisplay();
                this.saveState();
            }
        },
        
        removeScan(scanId) {
            this.activeScans.delete(scanId);
            this.pollIntervals.delete(scanId);
            this.updateDisplay();
            this.saveState();
            
            if (this.activeScans.size === 0) {
                this.hidePanel();
            }
        },
        
        updateDisplay() {
            if (!this.progressContent) return;
            
            if (this.activeScans.size === 0) {
                this.hidePanel();
                return;
            }
            
            let html = '';
            for (const [scanId, scan] of this.activeScans) {
                const elapsed = Math.round((Date.now() - scan.startTime) / 1000);
                const elapsedStr = elapsed < 60 ? `${elapsed}s` : `${Math.round(elapsed/60)}m ${elapsed%60}s`;
                
                // Handle counting phase differently
                let progressBar, progressInfo, progressText;
                
                if (scan.status === 'counting') {
                    // Show counting progress with a different style
                    progressBar = `<div class="progress-bar counting">
                        <div class="progress-fill counting" style="width: ${scan.totalFiles > 0 ? Math.round((scan.processedFiles / scan.totalFiles) * 100) : 0}%"></div>
                    </div>`;
                    progressInfo = `<span class="progress-counts">${scan.processedFiles} found</span>`;
                    progressText = scan.totalFiles > 0 ? `${Math.round((scan.processedFiles / scan.totalFiles) * 100)}%` : 'Counting...';
                } else {
                    // Normal scanning progress
                    progressBar = `<div class="progress-bar">
                        <div class="progress-fill" style="width: ${scan.progress}%"></div>
                    </div>`;
                    progressInfo = `<span class="progress-counts">${scan.processedFiles}/${scan.totalFiles}</span>`;
                    progressText = `${scan.progress}%`;
                }
                
                html += `
                    <div class="progress-indicator">
                        <div class="progress-header">
                            <span class="progress-icon">${scan.status === 'counting' ? 'üîç' : 'üîÑ'}</span>
                            <span class="progress-folder">${scan.folder.split('/').pop()}</span>
                        </div>
                        ${progressBar}
                        <div class="progress-info">
                            <span class="progress-text">${progressText}</span>
                            ${progressInfo}
                        </div>
                        <div class="progress-current">${scan.currentFile || 'Starting...'}</div>
                    </div>
                `;
            }
            
            this.progressContent.innerHTML = html;
            this.showPanel();
        },
        
        startPolling(scanId) {
            // Clear any existing interval
            if (this.pollIntervals.has(scanId)) {
                clearInterval(this.pollIntervals.get(scanId));
            }
            
            const pollInterval = setInterval(async () => {
                try {
                    const response = await fetch(`/api/scan-progress/${scanId}`);
                    const progress = await response.json();
                    
                    if (progress.error) {
                        this.updateScan(scanId, { status: 'error', currentFile: `Error: ${progress.error}` });
                        clearInterval(pollInterval);
                        this.pollIntervals.delete(scanId);
                        setTimeout(() => this.removeScan(scanId), 5000);
                        return;
                    }
                    
                    if (progress.status === 'completed') {
                        this.updateScan(scanId, { 
                            status: 'completed', 
                            progress: 100,
                            currentFile: 'Completed!'
                        });
                        clearInterval(pollInterval);
                        this.pollIntervals.delete(scanId);
                        setTimeout(() => this.removeScan(scanId), 5000);
                    } else if (progress.status === 'error') {
                        this.updateScan(scanId, { 
                            status: 'error', 
                            currentFile: `Failed: ${progress.error}` 
                        });
                        clearInterval(pollInterval);
                        this.pollIntervals.delete(scanId);
                        setTimeout(() => this.removeScan(scanId), 5000);
                    } else {
                        // Update progress
                        let progressPercent = 0;
                        if (progress.total_files > 0) {
                            progressPercent = Math.round((progress.files_processed / progress.total_files) * 100);
                        }
                        
                        this.updateScan(scanId, {
                            status: progress.status,
                            progress: progressPercent,
                            currentFile: progress.current_file || 'Processing...',
                            totalFiles: progress.total_files || 0,
                            processedFiles: progress.files_processed || 0
                        });
                    }
                } catch (error) {
                    console.error('Error polling scan progress:', error);
                }
            }, 2000); // Poll every 2 seconds
            
            this.pollIntervals.set(scanId, pollInterval);
        },
        
        ensureVisibility() {
            if (this.activeScans.size > 0) {
                this.showPanel();
                this.updateDisplay();
            }
        },
        
        setupEventHandlers() {
            // Page visibility change
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    this.ensureVisibility();
                }
            });
            
            // Page focus
            window.addEventListener('focus', () => {
                this.ensureVisibility();
            });
            
            // Page load
            window.addEventListener('load', () => {
                this.ensureVisibility();
            });
            
            // DOM ready
            document.addEventListener('DOMContentLoaded', () => {
                this.ensureVisibility();
            });
        },
        
        startBackgroundPolling() {
            // Persistent background monitoring
            setInterval(() => {
                this.ensureVisibility();
            }, 3000); // Check every 3 seconds
            
            // Restart polling for any scans that might have lost their intervals
            setInterval(() => {
                for (const [scanId, scan] of this.activeScans) {
                    if (!this.pollIntervals.has(scanId) && scan.status !== 'completed' && scan.status !== 'error') {
                        console.log(`Restarting polling for scan ${scanId}`);
                        this.startPolling(scanId);
                    }
                }
            }, 10000); // Check every 10 seconds
        }
    };

    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
        window.globalStatusManager.init();
    });
    </script>
    
    {% block extra_js %}{% endblock %}
</body>
</html>
