{% extends "layout.html" %}

{% block title %}Audio Analysis - TuneForge{% endblock %}

{% block content %}
<div class="audio-analysis-container">
    <div class="page-header">
        <h1>üéµ Audio Analysis Management</h1>
        <p>Manage and monitor audio feature extraction for your music library</p>
    </div>

    <!-- Analysis Overview -->
    <div class="analysis-overview">
        <div class="overview-card">
            <h3>üìä Library Overview</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="stat-number">{{ progress.total_tracks }}</span>
                    <span class="stat-label">Total Tracks</span>
                </div>
                <div class="stat-item">
                    <span class="stat-number">{{ progress.analyzed_tracks }}</span>
                    <span class="stat-label">Analyzed</span>
                </div>
                <div class="stat-item">
                    <span class="stat-number">{{ progress.pending_tracks }}</span>
                    <span class="stat-label">Pending</span>
                </div>
                <div class="stat-item">
                    <span class="stat-number">{{ progress.error_tracks }}</span>
                    <span class="stat-label">Errors</span>
                </div>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar">
                    <div id="page-progress-fill" class="progress-fill"></div>
                </div>
                <span id="page-progress-text" class="progress-text">0% Complete</span>
            </div>
        </div>
    </div>

    <!-- Control Panel -->
    <div class="control-panel">
        <div class="control-card">
            <h3>üéÆ Control Panel</h3>
            <div class="control-options">
                <div class="control-group">
                    <label for="batch-size">Batch Size:</label>
                    <select id="batch-size">
                        <option value="50">50 tracks</option>
                        <option value="100" selected>100 tracks</option>
                        <option value="200">200 tracks</option>
                        <option value="500">500 tracks</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="process-limit">Process Limit:</label>
                    <select id="process-limit">
                        <option value="">All pending tracks</option>
                        <option value="100">100 tracks</option>
                        <option value="500">500 tracks</option>
                        <option value="1000">1000 tracks</option>
                        <option value="5000">5000 tracks</option>
                    </select>
                </div>
            </div>
            <div class="control-buttons">
                <button id="start-analysis" class="btn btn-primary">
                    <span class="btn-icon">üöÄ</span>
                    Start Analysis
                </button>
                <button id="stop-analysis" class="btn btn-danger" style="display: none;">
                    <span class="btn-icon">‚èπÔ∏è</span>
                    Stop Analysis
                </button>
                <button id="refresh-status" class="btn btn-secondary">
                    <span class="btn-icon">üîÑ</span>
                    Refresh Status
                </button>
            </div>
        </div>
    </div>

    <!-- Live Status -->
    <div class="live-status">
        <div class="status-card">
            <h3>üì° Live Status</h3>
            <div id="live-status-content">
                <div class="status-item">
                    <span class="status-label">Status:</span>
                    <span id="analysis-status" class="status-value">Stopped</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Workers:</span>
                    <span id="active-workers" class="status-value">1 (Fixed)</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Queue Size:</span>
                    <span id="queue-size" class="status-value">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Processing:</span>
                    <span id="processing-jobs" class="status-value">0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Health Monitoring -->
    <div class="health-monitoring">
        <div class="health-card">
            <h3>üè• System Health</h3>
            <div id="health-status-content">
                <div class="health-overview">
                    <div class="health-indicator">
                        <span class="health-label">Overall Health:</span>
                        <span id="overall-health" class="health-value health-unknown">Unknown</span>
                    </div>
                    <div class="health-indicator">
                        <span class="health-label">Stall Status:</span>
                        <span id="stall-status" class="health-value health-unknown">Unknown</span>
                    </div>
                    <div class="health-indicator">
                        <span class="health-label">Last Update:</span>
                        <span id="last-health-update" class="health-value">Never</span>
                    </div>
                </div>
                <div class="health-details">
                    <div class="health-metrics">
                        <div class="health-metric">
                            <span class="metric-label">Processing Rate:</span>
                            <span id="processing-rate" class="metric-value">N/A</span>
                        </div>
                        <div class="health-metric">
                            <span class="metric-label">Stall Probability:</span>
                            <span id="stall-probability" class="metric-value">Unknown</span>
                        </div>
                        <div class="health-metric">
                            <span class="metric-label">Consecutive Stalls:</span>
                            <span id="consecutive-stalls" class="metric-value">0</span>
                        </div>
                    </div>
                    <div class="health-actions">
                        <button id="refresh-health" class="btn btn-info btn-sm">
                            <span class="btn-icon">üîÑ</span>
                            Refresh Health
                        </button>
                        <button id="force-restart" class="btn btn-warning btn-sm">
                            <span class="btn-icon">üîÑ</span>
                            Force Restart
                        </button>
                    </div>
                </div>
                <div class="health-recommendations">
                    <h4>üí° Recommendations</h4>
                    <div id="health-recommendations-list">
                        <div class="recommendation-item">
                            <span class="recommendation-text">System health monitoring is active</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Auto-Recovery Status -->
    <div class="auto-recovery-status">
        <div class="recovery-card">
            <h3>ü§ñ Auto-Recovery</h3>
            <div id="recovery-status-content">
                <div class="recovery-overview">
                    <div class="recovery-indicator">
                        <span class="recovery-label">Status:</span>
                        <span id="recovery-status" class="recovery-value recovery-unknown">Unknown</span>
                    </div>
                    <div class="recovery-indicator">
                        <span class="recovery-label">Monitoring:</span>
                        <span id="recovery-monitoring" class="recovery-value recovery-unknown">Unknown</span>
                    </div>
                    <div class="recovery-indicator">
                        <span class="recovery-label">Last Recovery:</span>
                        <span id="last-recovery-attempt" class="recovery-value">Never</span>
                    </div>
                </div>
                <div class="recovery-details">
                    <div class="recovery-metrics">
                        <div class="recovery-metric">
                            <span class="metric-label">Failures:</span>
                            <span id="recovery-failures" class="metric-value">0</span>
                        </div>
                        <div class="recovery-metric">
                            <span class="metric-label">Next Recovery:</span>
                            <span id="next-recovery-time" class="metric-value">Available now</span>
                        </div>
                        <div class="recovery-metric">
                            <span class="metric-label">Manual Intervention:</span>
                            <span id="manual-intervention" class="metric-value">Not required</span>
                        </div>
                    </div>
                    <div class="recovery-actions">
                        <button id="start-recovery-monitoring" class="btn btn-success btn-sm">
                            <span class="btn-icon">‚ñ∂Ô∏è</span>
                            Start Monitoring
                        </button>
                        <button id="stop-recovery-monitoring" class="btn btn-danger btn-sm">
                            <span class="btn-icon">‚èπÔ∏è</span>
                            Stop Monitoring
                        </button>
                        <button id="reset-recovery-failures" class="btn btn-warning btn-sm">
                            <span class="btn-icon">üîÑ</span>
                            Reset Failures
                        </button>
                    </div>
                </div>
                <div class="recovery-history">
                    <h4>üìã Recovery History</h4>
                    <div id="recovery-history-list">
                        <div class="history-item">
                            <span class="history-text">No recovery attempts yet</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Configuration Settings -->
    <div class="configuration-settings">
        <div class="config-card">
            <h3>‚öôÔ∏è Monitoring Configuration</h3>
            <div id="config-settings-content">
                <div class="config-sections">
                    <!-- Monitoring Settings -->
                    <div class="config-section">
                        <h4>üìä Monitoring</h4>
                        <div class="config-group">
                            <label for="stall-timeout">Stall Detection Timeout (seconds):</label>
                            <input type="number" id="stall-timeout" min="60" max="3600" value="300">
                        </div>
                        <div class="config-group">
                            <label for="monitoring-interval">Monitoring Interval (seconds):</label>
                            <input type="number" id="monitoring-interval" min="30" max="300" value="60">
                        </div>
                        <div class="config-group">
                            <label for="history-retention">Progress History Retention (days):</label>
                            <input type="number" id="history-retention" min="1" max="30" value="7">
                        </div>
                    </div>
                    
                    <!-- Auto-Recovery Settings -->
                    <div class="config-section">
                        <h4>ü§ñ Auto-Recovery</h4>
                        <div class="config-group">
                            <label for="auto-recovery-enabled">
                                <input type="checkbox" id="auto-recovery-enabled" checked>
                                Enable Auto-Recovery
                            </label>
                        </div>
                        <div class="config-group">
                            <label for="max-failures">Max Consecutive Failures:</label>
                            <input type="number" id="max-failures" min="1" max="10" value="3">
                        </div>
                        <div class="config-group">
                            <label for="backoff-multiplier">Recovery Backoff Multiplier:</label>
                            <input type="number" id="backoff-multiplier" min="1.0" max="5.0" step="0.1" value="2.0">
                        </div>
                    </div>
                    
                    <!-- Alert Thresholds -->
                    <div class="config-section">
                        <h4>üö® Alert Thresholds</h4>
                        <div class="config-group">
                            <label for="error-rate-threshold">High Error Rate Threshold (%):</label>
                            <input type="number" id="error-rate-threshold" min="1" max="50" step="0.1" value="10.0">
                        </div>
                        <div class="config-group">
                            <label for="stall-warning-threshold">Stall Warning Threshold:</label>
                            <input type="number" id="stall-warning-threshold" min="1" max="5" value="2">
                        </div>
                        <div class="config-group">
                            <label for="escalation-threshold">Escalation Threshold:</label>
                            <input type="number" id="escalation-threshold" min="2" max="10" value="3">
                        </div>
                    </div>
                    
                    <!-- UI Update Intervals -->
                    <div class="config-section">
                        <h4>üñ•Ô∏è UI Updates</h4>
                        <div class="config-group">
                            <label for="health-update-interval">Health Update Interval (seconds):</label>
                            <input type="number" id="health-update-interval" min="5" max="60" value="10">
                        </div>
                        <div class="config-group">
                            <label for="stall-detection-interval">Stall Detection Interval (seconds):</label>
                            <input type="number" id="stall-detection-interval" min="1" max="30" value="5">
                        </div>
                    </div>
                </div>
                
                <div class="config-actions">
                    <button id="save-config" class="btn btn-primary">
                        <span class="btn-icon">üíæ</span>
                        Save Configuration
                    </button>
                    <button id="reset-config" class="btn btn-secondary">
                        <span class="btn-icon">üîÑ</span>
                        Reset to Defaults
                    </button>
                    <button id="validate-config" class="btn btn-info">
                        <span class="btn-icon">‚úÖ</span>
                        Validate Configuration
                    </button>
                </div>
                
                <div class="config-status">
                    <div id="config-validation-result"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Progress Details -->
    <div class="progress-details">
        <div class="progress-card">
            <h3>üìà Progress Details</h3>
            <div id="progress-details-content">
                <div class="progress-grid">
                    <div class="progress-item">
                        <span class="progress-label">Total Jobs:</span>
                        <span id="total-jobs" class="progress-value">0</span>
                    </div>
                    <div class="progress-item">
                        <span class="progress-label">Completed:</span>
                        <span id="completed-jobs" class="progress-value">0</span>
                    </div>
                    <div class="progress-item">
                        <span class="progress-label">Failed:</span>
                        <span id="failed-jobs" class="progress-value">0</span>
                    </div>
                    <div class="progress-item">
                        <span class="progress-label">Retrying:</span>
                        <span id="retrying-jobs" class="progress-value">0</span>
                    </div>
                </div>
                <div class="progress-metrics">
                    <div class="metric-item">
                        <span class="metric-label">Success Rate:</span>
                        <span id="success-rate" class="metric-value">0%</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Average Time:</span>
                        <span id="avg-time" class="metric-value">0s</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">ETA:</span>
                        <span id="eta" class="metric-value">Calculating...</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Recent Activity -->
    <div class="recent-activity">
        <div class="activity-card">
            <h3>üìã Recent Activity</h3>
            <div id="recent-activity-content">
                <div class="activity-item">
                    <span class="activity-time">--:--</span>
                    <span class="activity-message">No recent activity</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Maintenance -->
    <div class="maintenance">
        <div class="maintenance-card">
            <h3>üîß Maintenance</h3>
            <div class="maintenance-options">
                <div class="maintenance-group">
                    <label for="cleanup-days">Clean up data older than:</label>
                    <select id="cleanup-days">
                        <option value="7">7 days</option>
                        <option value="30" selected>30 days</option>
                        <option value="90">90 days</option>
                        <option value="180">180 days</option>
                    </select>
                </div>
                <button id="cleanup-data" class="btn btn-warning">
                    <span class="btn-icon">üßπ</span>
                    Clean Up Old Data
                </button>
            </div>
        </div>
    </div>

    <!-- Problematic Files Management -->
    <div class="card mb-4">
        <div class="card-header d-flex justify-content-between align-items-center">
            <h5 class="mb-0">
                <i class="fas fa-exclamation-triangle text-warning"></i>
                Problematic Files Management
            </h5>
            <button class="btn btn-sm btn-outline-primary" onclick="window.audioAnalysisManager.refreshProblematicFiles()">
                <i class="fas fa-sync-alt"></i> Refresh
            </button>
        </div>
        <div class="card-body">
            <div id="problematic-files-content">
                <div class="text-center text-muted">
                    <i class="fas fa-spinner fa-spin"></i> Loading problematic files report...
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Status Messages -->
<div id="status-messages"></div>

<script>
// Audio Analysis Management JavaScript
class AudioAnalysisManager {
    constructor() {
        this.isRunning = false;
        this.statusInterval = null;
        this.progressInterval = null;
        this.lastKnownProgress = null;
        this.lastStatusCheck = 0;
        this.cachedProgress = null;  // Cache the last good progress value
        this.init();
    }

    init() {
        console.log('[AudioAnalysis] Initializing AudioAnalysisManager');
        console.log('[AudioAnalysis] Global status manager available:', !!window.globalStatusManager);
        console.log('[AudioAnalysis] Global status manager details:', window.globalStatusManager);
        if (window.globalStatusManager) {
            console.log('[AudioAnalysis] Global status manager methods:', Object.getOwnPropertyNames(window.globalStatusManager));
        }
        
        this.bindEvents();
        this.loadInitialStatus();
        this.startStatusPolling();
        
        // Initialize health monitoring
        this.refreshHealthStatus();
        this.refreshRecoveryStatus();
        
        // Load configuration
        this.loadConfiguration();
        
        // Start health monitoring polling
        this.startHealthPolling();
        
        // Load problematic files on page load
        this.refreshProblematicFiles();
        
        console.log('[AudioAnalysis] AudioAnalysisManager initialization complete');
    }

    bindEvents() {
        // Control buttons
        const startButton = document.getElementById('start-analysis');
        console.log('[AudioAnalysis] Start button found:', startButton);
        startButton.addEventListener('click', () => {
            console.log('[AudioAnalysis] Start button clicked');
            this.startAnalysis();
        });
        document.getElementById('stop-analysis').addEventListener('click', () => this.stopAnalysis());
        document.getElementById('refresh-status').addEventListener('click', () => this.refreshStatus());
        document.getElementById('cleanup-data').addEventListener('click', () => this.cleanupData());
        
        // Health monitoring buttons
        document.getElementById('refresh-health').addEventListener('click', () => this.refreshHealthStatus());
        document.getElementById('force-restart').addEventListener('click', () => this.forceRestart());
        
        // Auto-recovery buttons
        document.getElementById('start-recovery-monitoring').addEventListener('click', () => this.startRecoveryMonitoring());
        document.getElementById('stop-recovery-monitoring').addEventListener('click', () => this.stopRecoveryMonitoring());
        document.getElementById('reset-recovery-failures').addEventListener('click', () => this.resetRecoveryFailures());
        
        // Configuration buttons
        document.getElementById('save-config').addEventListener('click', () => this.saveConfiguration());
        document.getElementById('reset-config').addEventListener('click', () => this.resetConfiguration());
        document.getElementById('validate-config').addEventListener('click', () => this.validateConfiguration());
    }

    async startAnalysis() {
        console.log('[AudioAnalysis] startAnalysis called');
        try {
            const batchSize = parseInt(document.getElementById('batch-size').value);
            const limit = document.getElementById('process-limit').value || null;
            console.log('[AudioAnalysis] Batch size:', batchSize, 'Limit:', limit);

            // Add to global status manager immediately (same pattern as playlist generator)
            if (window.globalStatusManager) {
                console.log('[AudioAnalysis] Global status manager available');
                console.log('[AudioAnalysis] Global status manager state:', {
                    hasInit: typeof window.globalStatusManager.init === 'function',
                    hasAddAudioAnalysis: typeof window.globalStatusManager.addAudioAnalysis === 'function',
                    activeAudioAnalysis: window.globalStatusManager.activeAudioAnalysis
                });
                
                // Check if we should allow adding audio analysis
                const shouldAllow = this.shouldAllowAudioAnalysis();
                console.log('[AudioAnalysis] Should allow audio analysis:', shouldAllow);
                if (!shouldAllow) {
                    console.log('[AudioAnalysis] Preventing audio analysis from being added (recently stopped)');
                    return;
                }
                
                // Clear cache when starting new analysis
                this.cachedProgress = null;
                
                console.log('[AudioAnalysis] Calling globalStatusManager.addAudioAnalysis()');
                try {
                    window.globalStatusManager.addAudioAnalysis();
                    console.log('[AudioAnalysis] addAudioAnalysis() called successfully');
                } catch (error) {
                    console.error('[AudioAnalysis] Error calling addAudioAnalysis():', error);
                }
                
                // Initialize with cached progress if available
                if (this.cachedProgress && this.cachedProgress.progress_percentage > 0) {
                    window.globalStatusManager.updateAudioAnalysis({
                        progress: this.cachedProgress.progress_percentage,
                        processedTracks: this.cachedProgress.analyzed_tracks || 0,
                        totalTracks: this.cachedProgress.total_tracks || 0,
                        currentStatus: 'Resuming...',
                        queueSize: this.cachedProgress.pending_tracks || 0,
                        failedTracks: this.cachedProgress.error_tracks || 0
                    });
                }
            } else {
                console.warn('Global status manager not available to add audio analysis immediately');
            }

            console.log('[AudioAnalysis] Proceeding to API call...');
            console.log('[AudioAnalysis] Making API call to /api/audio-analysis/start');
            const response = await fetch('/api/audio-analysis/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ max_workers: 1, batch_size: batchSize, limit: limit })
            });
            console.log('[AudioAnalysis] API response received:', response.status);

            const result = await response.json();
            console.log('[AudioAnalysis] API result:', result);

            if (result.success) {
                this.showMessage(result.message, 'success');
                this.isRunning = true;
                this.updateControlButtons();
                this.startProgressPolling();
            } else {
                this.showMessage(result.error, 'error');
                
                // Remove from global status manager on error
                if (window.globalStatusManager) {
                    window.globalStatusManager.removeAudioAnalysis();
                }
            }
        } catch (error) {
            this.showMessage(`Error starting analysis: ${error.message}`, 'error');
            
            // Remove from global status manager on error
            if (window.globalStatusManager) {
                window.globalStatusManager.removeAudioAnalysis();
            }
        }
    }

    async stopAnalysis() {
        try {
            // Update global status manager first to show "Stopping..."
            if (window.globalStatusManager && window.globalStatusManager.activeAudioAnalysis) {
                window.globalStatusManager.updateAudioAnalysis({
                    status: 'stopping',
                    currentStatus: 'Stopping analysis...'
                });
            }
            
            const response = await fetch('/api/audio-analysis/stop', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });

            const result = await response.json();

            if (result.success) {
                this.showMessage(result.message, 'success');
                this.isRunning = false;
                this.updateControlButtons();
                
                // Stop ALL polling immediately
                this.stopProgressPolling();
                this.stopStatusPolling();
                
                // Set timestamp to prevent re-adding
                this.lastStatusCheck = Date.now();
                
                // Reset cached progress when stopping
                this.cachedProgress = null;
                
                // Remove from global status manager immediately
                if (window.globalStatusManager) {
                    window.globalStatusManager.removeAudioAnalysis();
                }
                
                // Double-check server status after a short delay to ensure indicator is removed
                setTimeout(async () => {
                    try {
                        const statusResponse = await fetch('/api/audio-analysis/status');
                        const status = await statusResponse.json();
                        
                        if (status.status === 'stopped' || status.status === 'completed') {
                            console.log(`[AudioAnalysis] Confirmed analysis ${status.status}, ensuring indicator is removed`);
                            // Force remove if still present
                            if (window.globalStatusManager && window.globalStatusManager.activeAudioAnalysis) {
                                window.globalStatusManager.removeAudioAnalysis();
                            }
                        }
                    } catch (error) {
                        console.error('Error checking final status:', error);
                    }
                }, 1000);
                
                // Update status to reflect stopped state
                await this.updateStatus();
                await this.updateProgress();
            } else {
                this.showMessage(result.error, 'error');
                
                // Reset global status manager on error
                if (window.globalStatusManager && window.globalStatusManager.activeAudioAnalysis) {
                    window.globalStatusManager.updateAudioAnalysis({
                        status: 'running',
                        currentStatus: 'Processing...'
                    });
                }
            }
        } catch (error) {
            this.showMessage(`Error stopping analysis: ${error.message}`, 'error');
            
            // Reset global status manager on error
            if (window.globalStatusManager && window.globalStatusManager.activeAudioAnalysis) {
                window.globalStatusManager.updateAudioAnalysis({
                    status: 'running',
                    currentStatus: 'Processing...'
                });
            }
        }
    }

    async refreshStatus() {
        await this.updateStatus();
        await this.updateProgress();
    }

    async cleanupData() {
        try {
            const daysOld = parseInt(document.getElementById('cleanup-days').value);
            
            const response = await fetch('/api/audio-analysis/cleanup', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ days_old: daysOld })
            });

            const result = await response.json();

            if (result.success) {
                this.showMessage(result.message, 'success');
                // Refresh progress after cleanup
                setTimeout(() => this.updateProgress(), 1000);
            } else {
                this.showMessage(result.error, 'error');
            }
        } catch (error) {
            this.showMessage(`Error cleaning up data: ${error.message}`, 'error');
        }
    }

    async loadInitialStatus() {
        await this.updateStatus();
        await this.updateProgress();
        
        // Set initial progress bar width from server data
        const initialProgressElement = document.getElementById('page-progress-text');
        if (initialProgressElement) {
            const initialProgressText = initialProgressElement.textContent;
            const initialProgress = parseInt(initialProgressText) || 0;
            const progressFill = document.getElementById('page-progress-fill');
            if (progressFill) {
                progressFill.style.width = `${initialProgress}%`;
            }
        }
    }

    async updateStatus() {
        try {
            const response = await fetch('/api/audio-analysis/status');
            const status = await response.json();

            // Update status display
            document.getElementById('analysis-status').textContent = status.status;
            document.getElementById('active-workers').textContent = status.workers || 0;
            document.getElementById('queue-size').textContent = status.queue_size || 0;
            document.getElementById('processing-jobs').textContent = status.processing_jobs || 0;

            // Update running state
            this.isRunning = status.status === 'running';
            this.updateControlButtons();

        } catch (error) {
            console.error('Error updating status:', error);
        }
    }

    async updateProgress() {
        try {
            const response = await fetch('/api/audio-analysis/progress');
            const result = await response.json();

            if (result.success) {
                const progress = result.progress;
                
                // Update progress values
                document.getElementById('total-jobs').textContent = progress.total_tracks || 0;
                document.getElementById('completed-jobs').textContent = progress.analyzed_tracks || 0;
                document.getElementById('failed-jobs').textContent = progress.error_tracks || 0;
                document.getElementById('retrying-jobs').textContent = '0'; // Not available in DB progress
                document.getElementById('success-rate').textContent = `${progress.progress_percentage || 0}%`;
                
                // Update main progress bar (scoped to this page only)
                const progressFill = document.getElementById('page-progress-fill');
                if (progressFill) {
                    progressFill.style.width = `${progress.progress_percentage || 0}%`;
                }
                
                // Update progress text (scoped to this page only)
                const progressText = document.getElementById('page-progress-text');
                if (progressText) {
                    progressText.textContent = `${progress.progress_percentage || 0}% Complete`;
                }
                
                // Only update global status manager on the first progress update or if we have valid data
                if (window.globalStatusManager && window.globalStatusManager.activeAudioAnalysis) {
                    const currentProgress = window.globalStatusManager.activeAudioAnalysis.progress;
                    
                    // Use cached progress if available, otherwise use current progress
                    const progressToUse = this.cachedProgress || progress;
                    
                    // Only update if this is the first update (progress === 0) or if we have valid progress data
                    if (currentProgress === 0 || (progressToUse.progress_percentage !== undefined && progressToUse.progress_percentage > 0)) {
                        window.globalStatusManager.updateAudioAnalysis({
                            progress: progressToUse.progress_percentage || currentProgress, // Use current progress if new data is invalid
                            processedTracks: progressToUse.analyzed_tracks || 0,
                            totalTracks: progressToUse.total_tracks || 0,
                            currentStatus: 'Processing...',
                            queueSize: progressToUse.pending_tracks || 0,
                            failedTracks: progressToUse.error_tracks || 0
                        });
                    }
                }
            }
        } catch (error) {
            console.error('Error updating progress:', error);
        }
    }

    startStatusPolling() {
        this.statusInterval = setInterval(async () => {
            // Only continue polling if analysis is still running
            if (!this.isRunning) {
                this.stopStatusPolling();
                return;
            }
            
            // Check if analysis has actually stopped on the server
            try {
                const response = await fetch('/api/audio-analysis/status');
                const status = await response.json();
                
                if (status.status === 'stopped' || status.status === 'completed') {
                    console.log(`[AudioAnalysis] Analysis status is ${status.status}, stopping all polling and removing indicator`);
                    this.isRunning = false;
                    this.stopStatusPolling();
                    this.stopProgressPolling();
                    
                    // Remove from global status manager
                    if (window.globalStatusManager && window.globalStatusManager.activeAudioAnalysis) {
                        window.globalStatusManager.removeAudioAnalysis();
                    }
                    
                    // Update UI
                    this.updateControlButtons();
                    this.showMessage(`Analysis ${status.status}`, 'info');
                    
                    // Prevent any further status checks for a short time
                    this.lastStatusCheck = Date.now();
                } else {
                    this.updateStatus();
                }
            } catch (error) {
                console.error('Error checking analysis status:', error);
                this.updateStatus();
            }
        }, 5000);
    }

    startProgressPolling() {
        this.progressInterval = setInterval(async () => {
            // Only continue polling if analysis is still running
            if (!this.isRunning) {
                this.stopProgressPolling();
                return;
            }
            
            // Get progress data first before updating anything
            const progressData = await this.getProgressData();
            
            // Use safe update to prevent flashing
            if (this.safeUpdateProgress(progressData)) {
                // Update the page progress display
                await this.updateProgress();
                
                // Update global status manager with the cached progress data
                if (window.globalStatusManager && window.globalStatusManager.activeAudioAnalysis) {
                    window.globalStatusManager.updateAudioAnalysis({
                        progress: this.cachedProgress.progress_percentage,
                        processedTracks: this.cachedProgress.analyzed_tracks || 0,
                        totalTracks: this.cachedProgress.total_tracks || 0,
                        currentStatus: 'Processing...',
                        queueSize: this.cachedProgress.pending_tracks || 0,
                        failedTracks: this.cachedProgress.error_tracks || 0
                    });
                }
            }
        }, 2000);
    }
    
    async getProgressData() {
        try {
            const response = await fetch('/api/audio-analysis/progress');
            const result = await response.json();
            
            if (result.success && result.progress) {
                // Store the last known good progress
                this.lastKnownProgress = result.progress;
                return result.progress;
            }
            return null;
        } catch (error) {
            console.error('Error getting progress data:', error);
            return null;
        }
    }
    
    getLastKnownProgress() {
        return this.lastKnownProgress || null;
    }
    
    shouldAllowAudioAnalysis() {
        // Prevent re-adding audio analysis if it was recently stopped (within 10 seconds)
        const timeSinceLastCheck = Date.now() - this.lastStatusCheck;
        const shouldAllow = timeSinceLastCheck > 10000;
        console.log('[AudioAnalysis] shouldAllowAudioAnalysis - lastStatusCheck:', this.lastStatusCheck, 'timeSinceLastCheck:', timeSinceLastCheck, 'shouldAllow:', shouldAllow, 'Date.now():', Date.now());
        return shouldAllow; // 10 seconds
    }
    
    startHealthPolling() {
        // Poll health status every 10 seconds for real-time updates
        setInterval(async () => {
            try {
                await this.refreshHealthStatus();
                await this.refreshRecoveryStatus();
            } catch (error) {
                console.error('Error in health polling:', error);
            }
        }, 10000); // 10 seconds for real-time updates
        
        // Also poll stall detection more frequently (every 5 seconds) when analysis is running
        setInterval(async () => {
            if (this.isRunning) {
                try {
                    await this.refreshHealthStatus();
                } catch (error) {
                    console.error('Error in stall detection polling:', error);
                }
            }
        }, 5000); // 5 seconds for stall detection
    }
    
    safeUpdateProgress(progressData) {
        // Only update if we have valid progress data
        if (!progressData || progressData.progress_percentage === undefined) {
            return false;
        }
        
        const newProgress = progressData.progress_percentage;
        
        // If this pie is the first update, cache it
        if (this.cachedProgress === null) {
            this.cachedProgress = progressData;
            return true;
        }
        
        // Only update if the new progress is better (higher) than cached
        if (newProgress > this.cachedProgress.progress_percentage) {
            this.cachedProgress = progressData;
            return true;
        }
        
        // If new progress is lower, don't update (prevents flashing to 0%)
        return false;
    }

    stopProgressPolling() {
        if (this.progressInterval) {
            clearInterval(this.progressInterval);
            this.progressInterval = null;
        }
    }
    
    stopStatusPolling() {
        if (this.statusInterval) {
            clearInterval(this.statusInterval);
            this.statusInterval = null;
        }
    }

    updateControlButtons() {
        const startBtn = document.getElementById('start-analysis');
        const stopBtn = document.getElementById('stop-analysis');

        if (this.isRunning) {
            startBtn.style.display = 'none';
            stopBtn.style.display = 'inline-block';
        } else {
            startBtn.style.display = 'inline-block';
            stopBtn.style.display = 'none';
        }
    }

    showMessage(message, type = 'info') {
        const messagesContainer = document.getElementById('status-messages');
        const messageElement = document.createElement('div');
        messageElement.className = `status-message status-${type}`;
        messageElement.textContent = message;
        
        messagesContainer.appendChild(messageElement);
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (messageElement.parentNode) {
                messageElement.parentNode.removeChild(messageElement);
            }
        }, 5000);
    }
    
    // Health Monitoring Methods
    async refreshHealthStatus() {
        try {
            const response = await fetch('/api/audio-analysis/health');
            const healthData = await response.json();
            
            if (healthData.success) {
                this.updateHealthDisplay(healthData.health, healthData.stall_analysis);
            } else {
                console.error('Failed to get health status:', healthData.error);
            }
        } catch (error) {
            console.error('Error refreshing health status:', error);
        }
    }
    
    updateHealthDisplay(health, stallAnalysis) {
        // Update overall health
        const overallHealth = document.getElementById('overall-health');
        if (overallHealth) {
            overallHealth.textContent = health.current_status;
            overallHealth.className = `health-value health-${health.current_status}`;
        }
        
        // Update stall status
        const stallStatus = document.getElementById('stall-status');
        if (stallStatus) {
            const isStalled = health.stalled ? 'Stalled' : 'Healthy';
            stallStatus.textContent = isStalled;
            stallStatus.className = `health-value health-${health.stalled ? 'stalled' : 'healthy'}`;
        }
        
        // Update last update time
        const lastUpdate = document.getElementById('last-health-update');
        if (lastUpdate) {
            const updateTime = new Date(health.timestamp).toLocaleTimeString();
            lastUpdate.textContent = updateTime;
        }
        
        // Update processing rate with real-time visualization
        const processingRate = document.getElementById('processing-rate');
        if (processingRate) {
            const rate = health.processing_rate;
            if (rate) {
                const rateText = `${rate.toFixed(2)} tracks/min`;
                processingRate.textContent = rateText;
                
                // Add visual indicators for processing rate
                if (rate > 1.0) {
                    processingRate.className = 'metric-value rate-high';
                } else if (rate > 0.5) {
                    processingRate.className = 'metric-value rate-medium';
                } else {
                    processingRate.className = 'metric-value rate-low';
                }
            } else {
                processingRate.textContent = 'N/A';
                processingRate.className = 'metric-value';
            }
        }
        
        // Update stall probability with real-time warnings
        const stallProbability = document.getElementById('stall-probability');
        if (stallProbability) {
            const probability = stallAnalysis.stall_probability || 'unknown';
            stallProbability.textContent = probability;
            
            // Add visual warnings for high stall probability
            if (probability === 'high') {
                stallProbability.className = 'metric-value stall-warning';
                this.showStallWarning();
            } else {
                stallProbability.className = 'metric-value';
                this.hideStallWarning();
            }
        }
        
        // Update consecutive stalls with escalation warnings
        const consecutiveStalls = document.getElementById('consecutive-stalls');
        if (consecutiveStalls) {
            const stalls = health.consecutive_stalls || 0;
            consecutiveStalls.textContent = stalls;
            
            // Show escalation warnings
            if (stalls >= 3) {
                consecutiveStalls.className = 'metric-value escalation-warning';
                this.showEscalationWarning(stalls);
            } else {
                consecutiveStalls.className = 'metric-value';
                this.hideEscalationWarning();
            }
        }
        
        // Update recommendations
        this.updateRecommendations(health.recommendations || []);
        
        // Update estimated completion time if available
        this.updateEstimatedCompletion(health.estimated_completion);
        
        // Show real-time alerts for critical issues
        this.checkCriticalAlerts(health, stallAnalysis);
    }
    
    // Configuration Management Methods
    async loadConfiguration() {
        try {
            const response = await fetch('/api/audio-analysis/config');
            const configData = await response.json();
            
            if (configData.success) {
                this.populateConfigurationForm(configData.config);
            } else {
                console.error('Failed to load configuration:', configData.error);
            }
        } catch (error) {
            console.error('Error loading configuration:', error);
        }
    }
    
    populateConfigurationForm(config) {
        // Populate form fields with current configuration
        document.getElementById('stall-timeout').value = config.stall_detection_timeout || 300;
        document.getElementById('monitoring-interval').value = config.monitoring_interval || 60;
        document.getElementById('history-retention').value = config.progress_history_retention_days || 7;
        
        document.getElementById('auto-recovery-enabled').checked = config.auto_recovery_enabled !== false;
        document.getElementById('max-failures').value = config.max_consecutive_failures || 3;
        document.getElementById('backoff-multiplier').value = config.recovery_backoff_multiplier || 2.0;
        
        document.getElementById('error-rate-threshold').value = config.high_error_rate_threshold || 10.0;
        document.getElementById('stall-warning-threshold').value = config.stall_warning_threshold || 2;
        document.getElementById('escalation-threshold').value = config.escalation_threshold || 3;
        
        document.getElementById('health-update-interval').value = config.health_update_interval || 10;
        document.getElementById('stall-detection-interval').value = config.stall_detection_interval || 5;
    }
    
    async saveConfiguration() {
        try {
            const config = this.collectConfigurationForm();
            
            const response = await fetch('/api/audio-analysis/config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(config)
            });
            
            const result = await response.json();
            
            if (result.success) {
                this.showMessage('Configuration saved successfully', 'success');
                this.showValidationResult(result.validation, 'Configuration saved and validated');
            } else {
                this.showMessage(`Failed to save configuration: ${result.error}`, 'error');
            }
        } catch (error) {
            this.showMessage(`Error saving configuration: ${error.message}`, 'error');
        }
    }
    
    collectConfigurationForm() {
        return {
            stall_detection_timeout: parseInt(document.getElementById('stall-timeout').value),
            monitoring_interval: parseInt(document.getElementById('monitoring-interval').value),
            progress_history_retention_days: parseInt(document.getElementById('history-retention').value),
            
            auto_recovery_enabled: document.getElementById('auto-recovery-enabled').checked,
            auto_recovery_check_interval: parseInt(document.getElementById('monitoring-interval').value),
            max_consecutive_failures: parseInt(document.getElementById('max-failures').value),
            recovery_backoff_multiplier: parseFloat(document.getElementById('backoff-multiplier').value),
            recovery_max_delay: 1800, // Default value
            
            high_error_rate_threshold: parseFloat(document.getElementById('error-rate-threshold').value),
            stall_warning_threshold: parseInt(document.getElementById('stall-warning-threshold').value),
            escalation_threshold: parseInt(document.getElementById('escalation-threshold').value),
            critical_stall_threshold: parseInt(document.getElementById('escalation-threshold').value) + 2,
            progress_stagnation_hours: 2, // Default value
            
            health_update_interval: parseInt(document.getElementById('health-update-interval').value),
            stall_detection_interval: parseInt(document.getElementById('stall-detection-interval').value),
            progress_update_interval: 2, // Default value
            recovery_status_interval: 15 // Default value
        };
    }
    
    async resetConfiguration() {
        try {
            const response = await fetch('/api/audio-analysis/config/reset', {
                method: 'POST'
            });
            
            const result = await response.json();
            
            if (result.success) {
                this.showMessage('Configuration reset to defaults', 'success');
                this.populateConfigurationForm(result.config);
                this.showValidationResult(result.validation, 'Configuration reset and validated');
            } else {
                this.showMessage(`Failed to reset configuration: ${result.error}`, 'error');
            }
        } catch (error) {
            this.showMessage(`Error resetting configuration: ${error.message}`, 'error');
        }
    }
    
    async validateConfiguration() {
        try {
            const config = this.collectConfigurationForm();
            
            const response = await fetch('/api/audio-analysis/config/validate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(config)
            });
            
            const result = await response.json();
            
            if (result.success) {
                this.showValidationResult(result.validation, 'Configuration validation completed');
            } else {
                this.showMessage(`Failed to validate configuration: ${result.error}`, 'error');
            }
        } catch (error) {
            this.showMessage(`Error validating configuration: ${error.message}`, 'error');
        }
    }
    
    showValidationResult(validation, message) {
        const container = document.getElementById('config-validation-result');
        if (!container) return;
        
        let className = 'validation-success';
        let icon = '‚úÖ';
        
        if (!validation.valid) {
            className = 'validation-error';
            icon = '‚ùå';
        } else if (validation.warnings && validation.warnings.length > 0) {
            className = 'validation-warning';
            icon = '‚ö†Ô∏è';
        }
        
        let html = `<div class="${className}">`;
        html += `<strong>${icon} ${message}</strong><br>`;
        
        if (validation.warnings && validation.warnings.length > 0) {
            html += '<strong>Warnings:</strong><ul>';
            validation.warnings.forEach(warning => {
                html += `<li>${warning}</li>`;
            });
            html += '</ul>';
        }
        
        if (validation.errors && validation.errors.length > 0) {
            html += '<strong>Errors:</strong><ul>';
            validation.errors.forEach(error => {
                html += `<li>${error}</li>`;
            });
            html += '</ul>';
        }
    }
    
    updateEstimatedCompletion(estimatedCompletion) {
        if (estimatedCompletion) {
            try {
                const completionTime = new Date(estimatedCompletion);
                const now = new Date();
                const timeRemaining = completionTime - now;
                
                if (timeRemaining > 0) {
                    const hours = Math.floor(timeRemaining / (1000 * 60 * 60));
                    const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
                    
                    let timeText = '';
                    if (hours > 0) {
                        timeText = `${hours}h ${minutes}m remaining`;
                    } else {
                        timeText = `${minutes}m remaining`;
                    }
                    
                    // Update the ETA display in progress details
                    const etaElement = document.getElementById('eta');
                    if (etaElement) {
                        etaElement.textContent = timeText;
                    }
                }
            } catch (error) {
                console.error('Error updating estimated completion:', error);
            }
        }
    }
    
    showStallWarning() {
        // Show visual stall warning
        const stallStatus = document.getElementById('stall-status');
        if (stallStatus) {
            stallStatus.style.animation = 'pulse-warning 2s infinite';
        }
        
        // Show notification
        this.showMessage('‚ö†Ô∏è High stall probability detected - monitoring closely', 'warning');
    }
    
    hideStallWarning() {
        const stallStatus = document.getElementById('stall-status');
        if (stallStatus) {
            stallStatus.style.animation = '';
        }
    }
    
    showEscalationWarning(stallCount) {
        // Show escalation warning for multiple consecutive stalls
        const warningMessage = `üö® ${stallCount} consecutive stalls detected - manual intervention may be required`;
        this.showMessage(warningMessage, 'error');
        
        // Highlight the consecutive stalls counter
        const consecutiveStalls = document.getElementById('consecutive-stalls');
        if (consecutiveStalls) {
            consecutiveStalls.style.animation = 'pulse-error 1s infinite';
        }
    }
    
    hideEscalationWarning() {
        const consecutiveStalls = document.getElementById('consecutive-stalls');
        if (consecutiveStalls) {
            consecutiveStalls.style.animation = '';
        }
    }
    
    checkCriticalAlerts(health, stallAnalysis) {
        // Check for critical issues that need immediate attention
        
        // Critical stall detection
        if (health.stalled && health.consecutive_stalls >= 2) {
            this.showCriticalAlert('üö® CRITICAL: Analysis has stalled multiple times. Immediate action required!', 'error');
        }
        
        // High error rate
        if (health.progress && health.progress.error_tracks > 0) {
            const errorRate = (health.progress.error_tracks / health.progress.total_tracks) * 100;
            if (errorRate > 10) {
                this.showCriticalAlert(`‚ö†Ô∏è High error rate: ${errorRate.toFixed(1)}% of tracks failed analysis`, 'warning');
            }
        }
        
        // Progress regression
        if (health.anomalies && health.anomalies.some(a => a.includes('Progress dropped'))) {
            this.showCriticalAlert('‚ö†Ô∏è Progress regression detected - analysis may be corrupted', 'warning');
        }
    }
    
    showCriticalAlert(message, type) {
        // Show critical alert that doesn't auto-dismiss
        const alertContainer = document.getElementById('critical-alerts') || this.createCriticalAlertContainer();
        
        const alertElement = document.createElement('div');
        alertElement.className = `critical-alert alert-${type}`;
        alertElement.innerHTML = `
            <span class="alert-icon">${type === 'error' ? 'üö®' : '‚ö†Ô∏è'}</span>
            <span class="alert-message">${message}</span>
            <button class="alert-dismiss" onclick="this.parentElement.remove()">√ó</button>
        `;
        
        alertContainer.appendChild(alertElement);
        
        // Auto-dismiss after 30 seconds for warnings
        if (type === 'warning') {
            setTimeout(() => {
                if (alertElement.parentNode) {
                    alertElement.remove();
                }
            }, 30000);
        }
    }
    
    createCriticalAlertContainer() {
        // Create critical alerts container if it doesn't exist
        const container = document.createElement('div');
        container.id = 'critical-alerts';
        container.className = 'critical-alerts-container';
        document.body.appendChild(container);
        return container;
    }
    
    updateRecommendations(recommendations) {
        const container = document.getElementById('health-recommendations-list');
        if (!container) return;
        
        container.innerHTML = '';
        
        if (recommendations.length === 0) {
            container.innerHTML = '<div class="recommendation-item"><span class="recommendation-text">No recommendations at this time</span></div>';
            return;
        }
        
        recommendations.forEach(rec => {
            const item = document.createElement('div');
            item.className = 'recommendation-item';
            item.innerHTML = `<span class="recommendation-text">‚Ä¢ ${rec}</span>`;
            container.appendChild(item);
        });
    }
    
    // Auto-Recovery Methods
    async refreshRecoveryStatus() {
        try {
            const response = await fetch('/api/audio-analysis/auto-recovery/status');
            const recoveryData = await response.json();
            
            if (recoveryData.success) {
                this.updateRecoveryDisplay(recoveryData.status, recoveryData.history);
            } else {
                console.error('Failed to get recovery status:', recoveryData.error);
            }
        } catch (error) {
            console.error('Error refreshing recovery status:', error);
        }
    }
    
    updateRecoveryDisplay(status, history) {
        // Update recovery status
        const recoveryStatus = document.getElementById('recovery-status');
        if (recoveryStatus) {
            recoveryStatus.textContent = status.status;
            recoveryStatus.className = `recovery-value recovery-${status.status}`;
        }
        
        // Update monitoring status
        const recoveryMonitoring = document.getElementById('recovery-monitoring');
        if (recoveryMonitoring) {
            const monitoringStatus = status.monitoring_active ? 'Active' : 'Inactive';
            recoveryMonitoring.textContent = monitoringStatus;
            recoveryMonitoring.className = `recovery-value recovery-${status.monitoring_active ? 'monitoring' : 'idle'}`;
        }
        
        // Update last recovery attempt
        const lastRecovery = document.getElementById('last-recovery-attempt');
        if (lastRecovery) {
            if (status.last_recovery_attempt) {
                const recoveryTime = new Date(status.last_recovery_attempt).toLocaleTimeString();
                lastRecovery.textContent = recoveryTime;
            } else {
                lastRecovery.textContent = 'Never';
            }
        }
        
        // Update recovery metrics
        const recoveryFailures = document.getElementById('recovery-failures');
        if (recoveryFailures) {
            recoveryFailures.textContent = status.consecutive_failures || '0';
        }
        
        const nextRecovery = document.getElementById('next-recovery-time');
        if (nextRecovery) {
            nextRecovery.textContent = status.next_recovery_available || 'Available now';
        }
        
        const manualIntervention = document.getElementById('manual-intervention');
        if (manualIntervention) {
            manualIntervention.textContent = status.requires_manual_intervention ? 'Required' : 'Not required';
        }
        
        // Update recovery history
        this.updateRecoveryHistory(history);
    }
    
    updateRecoveryHistory(history) {
        const container = document.getElementById('recovery-history-list');
        if (!container) return;
        
        container.innerHTML = '';
        
        if (history.length === 0) {
            container.innerHTML = '<div class="history-item"><span class="history-text">No recovery attempts yet</span></div>';
            return;
        }
        
        history.forEach(attempt => {
            const item = document.createElement('div');
            item.className = 'history-item';
            const successIcon = attempt.success ? '‚úÖ' : '‚ùå';
            const time = new Date(attempt.timestamp).toLocaleTimeString();
            item.innerHTML = `<span class="history-text">${successIcon} ${time} - ${attempt.reason}</span>`;
            container.appendChild(item);
        });
    }
    
    async startRecoveryMonitoring() {
        try {
            const response = await fetch('/api/audio-analysis/auto-recovery/start', {
                method: 'POST'
            });
            const result = await response.json();
            
            if (result.success) {
                this.showMessage('Auto-recovery monitoring started', 'success');
                this.refreshRecoveryStatus();
            } else {
                this.showMessage(`Failed to start monitoring: ${result.error}`, 'error');
            }
        } catch (error) {
            this.showMessage(`Error starting monitoring: ${error.message}`, 'error');
        }
    }
    
    async stopRecoveryMonitoring() {
        try {
            const response = await fetch('/api/audio-analysis/auto-recovery/stop', {
                method: 'POST'
            });
            const result = await response.json();
            
            if (result.success) {
                this.showMessage('Auto-recovery monitoring stopped', 'success');
                this.refreshRecoveryStatus();
            } else {
                this.showMessage(`Failed to stop monitoring: ${result.error}`, 'error');
            }
        } catch (error) {
            this.showMessage(`Error stopping monitoring: ${error.message}`, 'error');
        }
    }
    
    async resetRecoveryFailures() {
        try {
            const response = await fetch('/api/audio-analysis/auto-recovery/reset', {
                method: 'POST'
            });
            const result = await response.json();
            
            if (result.success) {
                this.showMessage('Recovery failure count reset', 'success');
                this.refreshRecoveryStatus();
            } else {
                this.showMessage(`Failed to reset failures: ${result.error}`, 'error');
            }
        } catch (error) {
            this.showMessage(`Error resetting failures: ${error.message}`, 'error');
        }
    }
    
    async forceRestart() {
        try {
            const response = await fetch('/api/audio-analysis/restart', {
                method: 'POST'
            });
            const result = await response.json();
            
            if (result.success) {
                this.showMessage('Audio analysis restarted successfully', 'success');
                this.refreshStatus();
                this.refreshHealthStatus();
            } else {
                this.showMessage(`Failed to restart: ${result.error}`, 'error');
            }
        } catch (error) {
            this.showMessage(`Error restarting analysis: ${error.message}`, 'error');
        }
    }
    
    cleanup() {
        // Stop all polling when cleaning up
        this.stopProgressPolling();
        this.stopStatusPolling();
        
        // Remove from global status manager if still active
        if (window.globalStatusManager && window.globalStatusManager.activeAudioAnalysis) {
            window.globalStatusManager.removeAudioAnalysis();
        }
    }

    // Problematic Files Management
    refreshProblematicFiles() {
        fetch('/api/audio-analysis/problematic-files')
            .then(response => response.json())
            .then(data => {
                this.displayProblematicFiles(data);
            })
            .catch(error => {
                console.error('Error fetching problematic files:', error);
                this.displayProblematicFiles({ error: 'Failed to load problematic files report' });
            });
    }

    displayProblematicFiles(data) {
        const container = document.getElementById('problematic-files-content');
        
        if (data.error) {
            container.innerHTML = `
                <div class="alert alert-danger">
                    <i class="fas fa-exclamation-circle"></i>
                    Error: ${data.error}
                </div>
            `;
            return;
        }

        let html = '';

        // Summary section
        if (data.summary) {
            const summary = data.summary;
            html += `
                <div class="row mb-3">
                    <div class="col-md-3">
                        <div class="text-center">
                            <div class="h4 text-primary">${summary.total_tracks || 0}</div>
                            <small class="text-muted">Total Tracks</small>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="text-center">
                            <div class="h4 text-warning">${summary.pending_tracks || 0}</div>
                            <small class="text-muted">Pending</small>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="text-center">
                            <div class="h4 text-success">${summary.completed_tracks || 0}</div>
                            <small class="text-muted">Completed</small>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="text-center">
                            <div class="h4 text-danger">${summary.error_tracks || 0}</div>
                            <small class="text-muted">Errors</small>
                        </div>
                    </div>
                </div>
            `;
        }

        // Problematic files section
        if (data.problematic_files && data.problematic_files.length > 0) {
            html += `
                <div class="mb-4">
                    <h6 class="text-warning">
                        <i class="fas fa-exclamation-triangle"></i>
                        Problematic Files (${data.problematic_files.length})
                    </h6>
                    <div class="table-responsive">
                        <table class="table table-sm table-hover">
                            <thead>
                                <tr>
                                    <th>Filename</th>
                                    <th>Failures</th>
                                    <th>Last Failure</th>
                                    <th>Error Message</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            data.problematic_files.forEach(file => {
                const filename = file.filename || 'Unknown';
                const shortPath = file.file_path ? file.file_path.substring(0, 50) + '...' : 'Unknown';
                
                html += `
                    <tr>
                        <td>
                            <div class="fw-bold">${filename}</div>
                            <small class="text-muted">${shortPath}</small>
                        </td>
                        <td>
                            <span class="badge bg-danger">${file.failure_count}</span>
                        </td>
                        <td>
                            <small>${file.last_failure || 'Unknown'}</small>
                        </td>
                        <td>
                            <small class="text-danger">${file.error_message ? file.error_message.substring(0, 60) + '...' : 'No error message'}</small>
                        </td>
                        <td>
                            <button class="btn btn-sm btn-outline-warning" 
                                    onclick="window.audioAnalysisManager.forceSkipFile('${file.file_path.replace(/'/g, '\\\'').replace(/"/g, '\\"')}', '${filename.replace(/'/g, '\\\'').replace(/"/g, '\\"')}')"
                                    title="Skip this file permanently">
                                <i class="fas fa-ban"></i> Skip
                            </button>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        // Stuck files section
        if (data.stuck_files && data.stuck_files.length > 0) {
            html += `
                <div class="mb-4">
                    <h6 class="text-info">
                        <i class="fas fa-clock"></i>
                        Stuck Files (${data.stuck_files.length})
                    </h6>
                    <div class="table-responsive">
                        <table class="table table-sm table-hover">
                            <thead>
                                <tr>
                                    <th>Filename</th>
                                    <th>Time Stuck</th>
                                    <th>Last Update</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            data.stuck_files.forEach(file => {
                const filename = file.filename || 'Unknown';
                const shortPath = file.file_path ? file.file_path.substring(0, 50) + '...' : 'Unknown';
                const timeClass = file.minutes_stuck > 300 ? 'text-danger' : 'text-warning';
                
                html += `
                    <tr>
                        <td>
                            <div class="fw-bold">${filename}</div>
                            <small class="text-muted">${shortPath}</small>
                        </td>
                        <td>
                            <span class="${timeClass}">${file.minutes_stuck.toFixed(1)} min</span>
                        </td>
                        <td>
                            <small>${file.last_updated || 'Unknown'}</small>
                        </td>
                        <td>
                            <button class="btn btn-sm btn-outline-info" 
                                    onclick="window.audioAnalysisManager.forceResetFile('${file.file_path.replace(/'/g, '\\\'').replace(/"/g, '\\"')}', '${filename.replace(/'/g, '\\\'').replace(/"/g, '\\"')}')"
                                    title="Reset this file to pending status">
                                <i class="fas fa-redo"></i> Reset
                            </button>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        // Error patterns section
        if (data.error_patterns && data.error_patterns.length > 0) {
            html += `
                <div class="mb-4">
                    <h6 class="text-danger">
                        <i class="fas fa-bug"></i>
                        Error Patterns (${data.error_patterns.length})
                    </h6>
                    <div class="table-responsive">
                        <table class="table table-sm table-hover">
                            <thead>
                                <tr>
                                    <th>Error Message</th>
                                    <th>Frequency</th>
                                    <th>Last Occurrence</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            data.error_patterns.forEach(pattern => {
                const freqClass = pattern.frequency === 'high' ? 'bg-danger' : 
                               pattern.frequency === 'medium' ? 'bg-warning' : 'bg-info';
                
                html += `
                    <tr>
                        <td>
                            <small class="text-danger">${pattern.error_message.substring(0, 80)}...</small>
                        </td>
                        <td>
                            <span class="badge ${freqClass}">${pattern.count}</span>
                        </td>
                        <td>
                            <small>${pattern.last_occurrence || 'Unknown'}</small>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        // Recommendations section
        if (data.recommendations && data.recommendations.length > 0) {
            html += `
                <div class="mb-3">
                    <h6 class="text-primary">
                        <i class="fas fa-lightbulb"></i>
                        Recommendations
                    </h6>
                    <ul class="list-unstyled">
            `;
            
            data.recommendations.forEach(rec => {
                html += `
                    <li class="mb-2">
                        <i class="fas fa-arrow-right text-primary"></i>
                        ${rec}
                    </li>
                `;
            });
            
            html += `
                    </ul>
                </div>
            `;
        }

        // No issues message
        if ((!data.problematic_files || data.problematic_files.length === 0) &&
            (!data.stuck_files || data.stuck_files.length === 0) &&
            (!data.error_patterns || data.error_patterns.length === 0)) {
            html += `
                <div class="text-center text-success py-4">
                    <i class="fas fa-check-circle fa-3x mb-3"></i>
                    <h5>No Problematic Files Detected</h5>
                    <p class="text-muted">Your audio analysis system is running smoothly!</p>
                </div>
            `;
        }

        container.innerHTML = html;
    }

    forceSkipFile(filePath, filename) {
        if (!confirm(`Are you sure you want to permanently skip "${filename}"?\n\nThis will mark the file as skipped and it won't be processed again.`)) {
            return;
        }

        fetch('/api/audio-analysis/force-skip', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                file_path: filePath,
                reason: 'Manually skipped by user to prevent stall'
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                this.showAlert('success', `File "${filename}" skipped successfully`);
                this.refreshProblematicFiles();
                this.refreshHealthStatus(); // Refresh health status
            } else {
                this.showAlert('danger', `Failed to skip file: ${data.error}`);
            }
        })
        .catch(error => {
            console.error('Error skipping file:', error);
            this.showAlert('danger', 'Error skipping file. Please try again.');
        });
    }

    forceResetFile(filePath, filename) {
        if (!confirm(`Are you sure you want to reset "${filename}"?\n\nThis will move the file back to pending status for retry.`)) {
            return;
        }

        fetch('/api/audio-analysis/force-reset', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                file_path: filePath,
                reason: 'Manually reset by user from stuck state'
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                this.showAlert('success', `File "${filename}" reset successfully`);
                this.refreshProblematicFiles();
                this.refreshHealthStatus(); // Refresh health status
            } else {
                this.showAlert('danger', `Failed to reset file: ${data.error}`);
            }
        })
        .catch(error => {
            console.error('Error resetting file:', error);
            this.showAlert('danger', 'Error resetting file. Please try again.');
        });
    }

    showAlert(type, message) {
        const messagesContainer = document.getElementById('status-messages');
        const messageElement = document.createElement('div');
        messageElement.className = `status-message status-${type}`;
        messageElement.textContent = message;
        
        messagesContainer.appendChild(messageElement);
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (messageElement.parentNode) {
                messageElement.parentNode.removeChild(messageElement);
            }
        }, 5000);
    }
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', () => {
    // Wait a bit for globalStatusManager to be ready
    setTimeout(() => {
        console.log('[AudioAnalysis] Creating AudioAnalysisManager after delay');
        window.audioAnalysisManager = new AudioAnalysisManager();
    }, 100);
});

// Clean up when page is unloaded
window.addEventListener('beforeunload', () => {
    if (window.audioAnalysisManager) {
        window.audioAnalysisManager.cleanup();
    }
});
</script>

<style>
.audio-analysis-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

.page-header {
    text-align: center;
    margin-bottom: 30px;
}

.page-header h1 {
    color: #6a8a5e;
    margin-bottom: 10px;
}

.page-header p {
    color: #888;
    font-size: 16px;
}

.analysis-overview, .control-panel, .live-status, .progress-details, .recent-activity, .maintenance {
    margin-bottom: 30px;
}

.overview-card, .control-card, .status-card, .progress-card, .activity-card, .maintenance-card, .health-card, .recovery-card, .config-card {
    background: #2a2a2a;
    border-radius: 12px;
    padding: 24px;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    border: 1px solid #444;
}

.overview-card h3, .control-card h3, .status-card h3, .progress-card h3, .activity-card h3, .maintenance-card h3, .health-card h3, .recovery-card h3, .config-card h3 {
    color: #6a8a5e;
    margin-bottom: 20px;
    font-size: 18px;
}



.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 20px;
    margin-bottom: 20px;
}

.stat-item {
    text-align: center;
}

.stat-number {
    display: block;
    font-size: 28px;
    font-weight: bold;
    color: #6a8a5e;
}

.stat-label {
    display: block;
    font-size: 12px;
    color: #888;
    text-transform: uppercase;
    margin-top: 5px;
}

.progress-bar-container {
    margin-top: 20px;
}

.progress-bar {
    height: 8px;
    background: #444;
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 10px;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #6a8a5e, #8bc34a);
    transition: width 0.3s ease;
}

.progress-text {
    font-size: 14px;
    color: #888;
}

/* Audio Analysis Progress Indicator Styles */
.progress-indicator.audio-analysis {
    border-left: 4px solid #9C27B0;
    background: rgba(42, 42, 42, 0.95);
}

.progress-indicator.audio-analysis .progress-header {
    color: #e0e0e0;
}

.progress-indicator.audio-analysis .progress-fill {
    background: linear-gradient(90deg, #9C27B0, #7B1FA2);
}

.control-options {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-bottom: 20px;
}

.control-group {
    display: flex;
    flex-direction: column;
}

.control-group label {
    font-size: 14px;
    color: #ccc;
    margin-bottom: 8px;
}

.control-group select {
    padding: 8px 12px;
    border: 1px solid #555;
    border-radius: 6px;
    background: #333;
    color: #fff;
    font-size: 14px;
}

.control-buttons {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
}

.btn {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    gap: 8px;
}

.btn-primary {
    background: #6a8a5e;
    color: white;
}

.btn-primary:hover {
    background: #5a7a4e;
}

.btn-danger {
    background: #dc3545;
    color: white;
}

.btn-danger:hover {
    background: #c82333;
}

.btn-secondary {
    background: #6c757d;
    color: white;
}

.btn-secondary:hover {
    background: #5a6268;
}

.btn-warning {
    background: #ffc107;
    color: #212529;
}

.btn-warning:hover {
    background: #e0a800;
}

.status-item, .progress-item, .metric-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 0;
    border-bottom: 1px solid #444;
}

.status-item:last-child, .progress-item:last-child, .metric-item:last-child {
    border-bottom: none;
}

.status-label, .progress-label, .metric-label {
    font-size: 14px;
    color: #ccc;
}

.status-value, .progress-value, .metric-value {
    font-size: 14px;
    color: #6a8a5e;
    font-weight: 500;
}

.progress-grid, .progress-metrics {
    margin-bottom: 20px;
}

.activity-item {
    display: flex;
    gap: 15px;
    padding: 10px 0;
    border-bottom: 1px solid #444;
}

.activity-item:last-child {
    border-bottom: none;
}

.activity-time {
    font-size: 12px;
    color: #888;
    min-width: 60px;
}

.activity-message {
    font-size: 14px;
    color: #ccc;
}

.maintenance-options {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.maintenance-group {
    display: flex;
    flex-direction: column;
}

.maintenance-group label {
    font-size: 14px;
    color: #ccc;
    margin-bottom: 8px;
}

.maintenance-group select {
    padding: 8px 12px;
    border: 1px solid #555;
    border-radius: 6px;
    background: #333;
    color: #fff;
    font-size: 14px;
    max-width: 200px;
}

#status-messages {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1000;
}

.status-message {
    padding: 12px 20px;
    margin-bottom: 10px;
    border-radius: 8px;
    color: white;
    font-size: 14px;
    animation: slideIn 0.3s ease;
}

.status-success {
    background: #28a745;
}

.status-error {
    background: #dc3545;
}

.status-info {
    background: #17a2b8;
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

/* Health Monitoring Styles */
.health-monitoring, .auto-recovery-status {
    margin-bottom: 30px;
}

.health-overview, .recovery-overview {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-bottom: 20px;
}

.health-indicator, .recovery-indicator {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 0;
    border-bottom: 1px solid #444;
}

.health-label, .recovery-label {
    font-size: 14px;
    color: #ccc;
}

.health-value, .recovery-value {
    font-size: 14px;
    font-weight: 500;
    padding: 4px 8px;
    border-radius: 4px;
}

/* Health Status Colors */
.health-healthy {
    color: #28a745;
    background: rgba(40, 167, 69, 0.1);
}

.health-warning {
    color: #ffc107;
    background: rgba(255, 193, 7, 0.1);
}

.health-stalled {
    color: #dc3545;
    background: rgba(220, 53, 69, 0.1);
}

.health-error {
    color: #dc3545;
    background: rgba(220, 53, 69, 0.1);
}

.health-unknown {
    color: #6c757d;
    background: rgba(108, 117, 125, 0.1);
}

/* Recovery Status Colors */
.recovery-monitoring {
    color: #28a745;
    background: rgba(40, 167, 69, 0.1);
}

.recovery-idle {
    color: #6c757d;
    background: rgba(108, 117, 125, 0.1);
}

.recovery-recovering {
    color: #ffc107;
    background: rgba(255, 193, 7, 0.1);
}

.recovery-failed {
    color: #dc3545;
    background: rgba(220, 53, 69, 0.1);
}

.recovery-unknown {
    color: #6c757d;
    background: rgba(108, 117, 125, 0.1);
}

.health-details, .recovery-details {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 20px;
    margin-bottom: 20px;
    align-items: start;
}

.health-metrics, .recovery-metrics {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 15px;
}

.health-metric, .recovery-metric {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.health-actions, .recovery-actions {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.btn-sm {
    padding: 8px 16px;
    font-size: 12px;
}

.btn-info {
    background: #17a2b8;
    color: white;
}

.btn-info:hover {
    background: #138496;
}

.health-recommendations, .recovery-history {
    margin-top: 20px;
}

.health-recommendations h4, .recovery-history h4 {
    color: #6a8a5e;
    margin-bottom: 15px;
    font-size: 16px;
}

.recommendation-item, .history-item {
    padding: 10px 0;
    border-bottom: 1px solid #444;
}

.recommendation-item:last-child, .history-item:last-child {
    border-bottom: none;
}

.recommendation-text, .history-text {
    font-size: 14px;
    color: #ccc;
}

/* Real-time Warning Styles */
.rate-high {
    color: #28a745 !important;
    font-weight: bold;
}

.rate-medium {
    color: #ffc107 !important;
    font-weight: bold;
}

.rate-low {
    color: #dc3545 !important;
    font-weight: bold;
}

.stall-warning {
    color: #ffc107 !important;
    font-weight: bold;
    background: rgba(255, 193, 7, 0.2) !important;
}

.escalation-warning {
    color: #dc3545 !important;
    font-weight: bold;
    background: rgba(220, 53, 69, 0.2) !important;
}

/* Critical Alerts Container */
.critical-alerts-container {
    position: fixed;
    top: 80px;
    right: 20px;
    z-index: 1001;
    max-width: 400px;
}

.critical-alert {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 15px;
    margin-bottom: 10px;
    border-radius: 8px;
    color: white;
    font-size: 14px;
    font-weight: 500;
    animation: slideInRight 0.3s ease;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
}

.alert-error {
    background: #dc3545;
    border-left: 4px solid #721c24;
}

.alert-warning {
    background: #ffc107;
    color: #212529;
    border-left: 4px solid #856404;
}

.alert-icon {
    font-size: 18px;
    flex-shrink: 0;
}

.alert-message {
    flex-grow: 1;
}

.alert-dismiss {
    background: none;
    border: none;
    color: inherit;
    font-size: 20px;
    cursor: pointer;
    padding: 0;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: background-color 0.2s ease;
}

.alert-dismiss:hover {
    background: rgba(255, 255, 255, 0.2);
}

/* Animations */
@keyframes pulse-warning {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

@keyframes pulse-error {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
}

@keyframes slideInRight {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

/* Responsive Design */
@media (max-width: 768px) {
    .health-details, .recovery-details {
        grid-template-columns: 1fr;
    }
    
    .health-actions, .recovery-actions {
        flex-direction: row;
        flex-wrap: wrap;
    }
    
    .critical-alerts-container {
        right: 10px;
        left: 10px;
        max-width: none;
    }
}

/* Configuration Settings Styles */
.configuration-settings {
    margin-bottom: 30px;
}

.config-sections {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
    margin-bottom: 20px;
}

.config-section {
    background: #333;
    border-radius: 8px;
    padding: 16px;
    border: 1px solid #555;
}

.config-section h4 {
    color: #6a8a5e;
    margin-bottom: 15px;
    font-size: 16px;
    border-bottom: 1px solid #555;
    padding-bottom: 8px;
}

.config-group {
    margin-bottom: 15px;
}

.config-group label {
    display: block;
    font-size: 14px;
    color: #ccc;
    margin-bottom: 8px;
}

.config-group input[type="number"],
.config-group input[type="text"] {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #555;
    border-radius: 6px;
    background: #444;
    color: #fff;
    font-size: 14px;
}

.config-group input[type="checkbox"] {
    margin-right: 8px;
    transform: scale(1.2);
}

.config-group input[type="checkbox"] + span {
    color: #ccc;
    font-size: 14px;
}

.config-actions {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    margin-bottom: 20px;
}

.config-status {
    min-height: 60px;
}

#config-validation-result {
    padding: 12px;
    border-radius: 6px;
    font-size: 14px;
}

.validation-success {
    background: rgba(40, 167, 69, 0.2);
    border: 1px solid #28a745;
    color: #28a745;
}

.validation-warning {
    background: rgba(255, 193, 7, 0.2);
    border: 1px solid #ffc107;
    color: #ffc107;
}

.validation-error {
    background: rgba(220, 53, 69, 0.2);
    border: 1px solid #dc3545;
    color: #dc3545;
}

/* Responsive Design for Configuration */
@media (max-width: 768px) {
    .config-sections {
        grid-template-columns: 1fr;
    }
    
    .config-actions {
        flex-direction: column;
    }
}

@media (max-width: 768px) {
    .audio-analysis-container {
        padding: 15px;
    }
    
    .control-options {
        grid-template-columns: 1fr;
    }
    
    .control-buttons {
        flex-direction: column;
    }
    
    .stats-grid {
        grid-template-columns: repeat(2, 1fr);
    }
}
</style>
{% endblock %}
