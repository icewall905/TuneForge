{% extends 'layout.html' %}

{% block title %}Generate Playlist - TuneForge{% endblock %}

{% block content %}
<div class="content-container">
    <h1>Generate Playlist</h1>
    
    <div class="playlist-container">
        <form id="playlistForm">
            <div class="settings-section">
                <div class="form-group">
                    <label for="playlist_name">Playlist Name:</label>
                    <input type="text" id="playlist_name" name="playlist_name" class="form-control" placeholder="Enter playlist name (optional)">
                </div>
                
                <div class="form-group">
                    <label for="playlist_description">Playlist Description:</label>
                    <textarea id="playlist_description" name="playlist_description" class="form-control" rows="2" placeholder="Enter a description for your playlist (optional)"></textarea>
                </div>
                
                <div class="form-group">
                    <label for="num_songs">Number of Tracks:</label>
                    <select id="num_songs" name="num_songs" class="form-control">
                        <option value="5">5 tracks</option>
                        <option value="10" selected>10 tracks</option>
                        <option value="15">15 tracks</option>
                        <option value="20">20 tracks</option>
                        <option value="25">25 tracks</option>
                        <option value="30">30 tracks</option>
                        <option value="40">40 tracks</option>
                        <option value="50">50 tracks</option>
                        <option value="75">75 tracks</option>
                        <option value="100">100 tracks</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="likes">My Likes:</label>
                    <textarea id="likes" name="likes" class="form-control" rows="3" placeholder="Genres, artists, moods that you like">{{ likes }}</textarea>
                </div>
                
                <div class="form-group">
                    <label for="dislikes">My Dislikes:</label>
                    <textarea id="dislikes" name="dislikes" class="form-control" rows="3" placeholder="Genres, artists, moods that you dislike">{{ dislikes }}</textarea>
                </div>
                
                <div class="form-group">
                    <label for="artist_input">Add Favorite Artist:</label>
                    <div class="input-group">
                        <input type="text" id="artist_input" class="form-control" placeholder="Enter artist name">
                        <button type="button" id="add_artist" class="secondary-button">Add</button>
                    </div>
                </div>
                
                <input type="hidden" id="favorite_artists" name="favorite_artists" value="{{ favorite_artists }}">
                
                <div class="form-group">
                    <label>Favorite Artists:</label>
                    <ul id="artist_list" class="list-group"></ul>
                </div>
                
                <div class="form-group">
                    <button type="submit" class="primary-button">Generate Playlist</button>
                </div>
            </div>
        </form>
        
        <div id="loading" style="display:none;" class="loading-large">
            <p>Generating playlist, please wait...</p>
        </div>
        
        <div class="results-container">
            <h2>Console Output</h2>
            <div id="console_output" class="console-output"></div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    // Prevent double-handling of submissions
    window.__playlistSubmitInProgress = false;

    // Global error handler to log JavaScript errors
    window.addEventListener('error', function(e) {
        console.error('JavaScript error:', e.error);
        console.error('Error location:', e.filename, e.lineno, e.colno);
        console.error('Error message:', e.message);
        
        // Try to send error to backend for logging
        fetch('/api/log-error', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                message: e.message,
                filename: e.filename,
                lineno: e.lineno,
                colno: e.colno,
                error: e.error ? e.error.toString() : 'Unknown error'
            })
        }).catch(err => console.error('Failed to log error to backend:', err));
    });
    
    // Comprehensive JavaScript execution tracking
    console.log('=== TUNEFORGE JAVASCRIPT LOADING STARTED ===');
    console.log('Timestamp:', new Date().toISOString());
    console.log('User Agent:', navigator.userAgent);
    console.log('Document ready state:', document.readyState);
    
    document.addEventListener('DOMContentLoaded', function() {
        console.log('=== DOM CONTENT LOADED EVENT FIRED ===');
        console.log('Document ready state:', document.readyState);
        console.log('Form element exists:', !!document.getElementById('playlistForm'));
        console.log('Submit button exists:', !!document.querySelector('button[type="submit"]'));
        
        function updateHiddenInput() {
            const listItems = document.querySelectorAll('#artist_list li');
            const artists = Array.from(listItems).map(item => item.querySelector('.artist-name').textContent);
            document.getElementById('favorite_artists').value = artists.join(', ');
        }
        
        function addArtist() {
            const input = document.getElementById('artist_input');
            const artistName = input.value.trim();
            if (artistName === '') return;
            
            const li = document.createElement('li');
            li.className = "list-group-item";
            
            const artistSpan = document.createElement('span');
            artistSpan.className = 'artist-name';
            artistSpan.textContent = artistName;
            li.appendChild(artistSpan);
            
            const removeBtn = document.createElement('button');
            removeBtn.type = "button";
            removeBtn.className = "text-button";
            removeBtn.textContent = 'Remove';
            removeBtn.onclick = function() { 
                li.remove(); 
                updateHiddenInput(); 
            };
            li.appendChild(removeBtn);
            
            document.getElementById('artist_list').appendChild(li);
            input.value = '';
            updateHiddenInput();
        }
        
        document.getElementById('add_artist').addEventListener('click', addArtist);
        
        // Initialize favorite artists from hidden input
        window.onload = function() {
            const hiddenInput = document.getElementById('favorite_artists');
            const existing = hiddenInput.value;
            if (existing.trim() !== '') {
                const artists = existing.split(',').map(a => a.trim());
                artists.forEach(function(artist) {
                    if (artist !== '') {
                        document.getElementById('artist_input').value = artist;
                        addArtist();
                    }
                });
            }
            
            // Check if global status manager is ready
            if (window.globalStatusManager) {
                console.log('Global status manager is ready!');
            } else {
                console.log('Global status manager not ready yet, waiting...');
                // Wait a bit more for it to initialize
                setTimeout(() => {
                    if (window.globalStatusManager) {
                        console.log('Global status manager is now ready!');
                    } else {
                        console.error('Global status manager still not available after delay!');
                    }
                }, 1000);
            }
        };
        
        // Handle form submission for playlist generation
        console.log('=== SETTING UP FORM SUBMISSION HANDLER ===');
        const form = document.getElementById('playlistForm');
        console.log('Form element found:', !!form);
        console.log('Form element:', form);
        
        if (!form) {
            console.error('CRITICAL ERROR: Form not found!');
            return;
        }
        
        // Single guard for both handlers
        function handleSubmit(e) {
            console.log('=== FORM SUBMIT EVENT ===');
            if (window.__playlistSubmitInProgress) {
                console.log('Submission already in progress; ignoring duplicate submit');
                e.preventDefault();
                e.stopPropagation();
                return;
            }
            window.__playlistSubmitInProgress = true;

            e.preventDefault();
            e.stopPropagation();

            // Proceed
            processFormSubmission(e);
        }
        
        try {
            form.addEventListener('submit', handleSubmit);
            console.log('‚úÖ addEventListener submit handler attached successfully');
        } catch (error) {
            console.error('‚ùå Failed to attach addEventListener submit handler:', error);
        }
        
        try {
            form.onsubmit = handleSubmit;
            console.log('‚úÖ onsubmit handler attached successfully');
        } catch (error) {
            console.error('‚ùå Failed to attach onsubmit handler:', error);
        }
        
        // Function to process form submission
        function processFormSubmission(e) {
            document.getElementById('loading').style.display = 'block';
            const outputElement = document.getElementById('console_output');
            outputElement.innerHTML = '<div class="console-line">üöÄ Starting playlist generation...</div>';
            
            // Collect form data
            const formData = new FormData(e.target);
            const formDataObj = {};
            formData.forEach((value, key) => {
                formDataObj[key] = value;
            });
            
            console.log('Form data collected:', formDataObj);
            
            // Create the payload in the format expected by the API
            const payload = {
                prompt: `Create a playlist with these preferences: 
                    Likes: ${formDataObj.likes}
                    Dislikes: ${formDataObj.dislikes}
                    Favorite Artists: ${formDataObj.favorite_artists}
                    ${formDataObj.playlist_description ? 'Description: ' + formDataObj.playlist_description : ''}`,
                num_songs: parseInt(formDataObj.num_songs) || 10,
                playlist_name: formDataObj.playlist_name || "TuneForge Playlist"
            };
            
            console.log('API payload created:', payload);

            // Generate a client-side playlist ID and register in sidebar immediately
            const clientPlaylistId = (window.crypto && window.crypto.randomUUID) ? window.crypto.randomUUID() : `${Date.now()}-${Math.random().toString(16).slice(2)}`;
            payload.client_playlist_id = clientPlaylistId;
            
            if (window.globalStatusManager) {
                window.globalStatusManager.addPlaylist(
                    clientPlaylistId,
                    payload.playlist_name,
                    payload.num_songs
                );
            } else {
                console.warn('Global status manager not available to add playlist immediately');
            }
            
            // Start log streaming IMMEDIATELY to capture logs as they happen
            startLogStreaming(outputElement);
            
            // Start the playlist generation
            fetch('/api/generate-playlist', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            })
            .then(response => {
                console.log('API response received:', response);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('API data received:', data);
                console.log('Playlist ID found:', data.playlist_id);
                console.log('Global status manager available:', !!window.globalStatusManager);
                
                // If server returned a different playlist_id (shouldn't), reconcile by updating map key
                if (data.playlist_id && data.playlist_id !== clientPlaylistId && window.globalStatusManager) {
                    const existing = window.globalStatusManager.activePlaylists.get(clientPlaylistId);
                    if (existing) {
                        window.globalStatusManager.activePlaylists.delete(clientPlaylistId);
                        window.globalStatusManager.activePlaylists.set(data.playlist_id, Object.assign(existing, { id: data.playlist_id }));
                        window.globalStatusManager.updateDisplay();
                        window.globalStatusManager.saveState();
                    }
                }
                
                // Show the final result immediately
                displayFinalResult(outputElement, data);
                
                // Allow new submissions after this completes
                window.__playlistSubmitInProgress = false;
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('loading').style.display = 'none';
                outputElement.innerHTML += `<div class="console-line error">‚ùå Error: ${error}</div>`;
                window.__playlistSubmitInProgress = false;
            });
        }
        
        function startLogStreaming(outputElement) {
            console.log('Starting log streaming...');
            outputElement.innerHTML += `<div class="console-line info">üîå Connecting to log stream...</div>`;
            
            // Start real-time log streaming
            const eventSource = new EventSource('/api/logs/stream');
            
            // Store reference to close later
            window.currentEventSource = eventSource;
            
            // Function to add log line with line limit management
            function addLogLine(html) {
                outputElement.innerHTML += html;
                
                // Limit console output to 100 lines to prevent browser hanging
                const lines = outputElement.querySelectorAll('.console-line');
                if (lines.length > 100) {
                    // Remove oldest lines (keep the last 100)
                    const linesToRemove = lines.length - 100;
                    for (let i = 0; i < linesToRemove; i++) {
                        lines[i].remove();
                    }
                }
                
                // Auto-scroll to bottom
                outputElement.scrollTop = outputElement.scrollHeight;
            }
            
            eventSource.onopen = function(event) {
                console.log('EventSource opened');
                addLogLine(`<div class="console-line success">üîó Log stream connected!</div>`);
            };
            
            eventSource.onmessage = function(event) {
                console.log('Received message:', event.data);
                try {
                    const data = JSON.parse(event.data);
                    
                    switch(data.type) {
                        case 'info':
                            addLogLine(`<div class="console-line info">‚ÑπÔ∏è ${data.message}</div>`);
                            break;
                        case 'log':
                            // Parse the log message and display it nicely
                            const logMessage = parseLogMessage(data.message);
                            addLogLine(`<div class="console-line log">${logMessage}</div>`);
                            break;
                        case 'error':
                            addLogLine(`<div class="console-line error">‚ùå ${data.message}</div>`);
                            break;
                        case 'complete':
                            addLogLine(`<div class="console-line success">‚úÖ ${data.message}</div>`);
                            // Don't close here - let it keep running to capture more logs
                            break;
                    }
                } catch (e) {
                    console.error('Error parsing log message:', e);
                    addLogLine(`<div class="console-line error">‚ùå Parse error: ${e.message}</div>`);
                }
            };
            
            eventSource.onerror = function(event) {
                console.error('EventSource error:', event);
                addLogLine(`<div class="console-line error">‚ùå Connection error - check browser console</div>`);
                // Don't close on error - let it retry
            };
        }
        
        function parseLogMessage(logLine) {
            // Extract the relevant part of the log message
            if (logLine.includes('Ollama:')) {
                const message = logLine.split('Ollama:')[1]?.trim() || logLine;
                return `ü§ñ ${message}`;
            } else if (logLine.includes('Navidrome:')) {
                const message = logLine.split('Navidrome:')[1]?.trim() || logLine;
                return `üéµ ${message}`;
            } else if (logLine.includes('Playlist Gen:')) {
                const message = logLine.split('Playlist Gen:')[1]?.trim() || logLine;
                return `üìã ${message}`;
            } else {
                return `üìù ${logLine}`;
            }
        }
        
        function displayLogMessage(outputElement, data) {
            let className = 'console-line';
            let icon = 'üìù';
            
            switch(data.status) {
                case 'starting':
                    className += ' info';
                    icon = 'üîÑ';
                    break;
                case 'progress':
                    className += ' info';
                    icon = 'üìù';
                    break;
                case 'complete':
                    className += ' success';
                    icon = '‚úÖ';
                    break;
                case 'error':
                    className += ' error';
                    icon = '‚ùå';
                    break;
            }
            
            outputElement.innerHTML += `<div class="${className}">${icon} ${data.message}</div>`;
            outputElement.scrollTop = outputElement.scrollHeight;
        }

        // Note: Removed local startPlaylistProgressPolling; sidebar now handles polling
    });
</script>
{% endblock %}